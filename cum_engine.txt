--@name cum_framework/CUM engine
--@author ced555
--@server
--@model models/props_c17/SuitCase001a.mdl

-- Engine Settings --
local torquemin = 480            * 4.5-- made it run every 1/16th of a second instead of every tick so its has to be buffed to remain the same as before
local torquemax = 590           * 4.5
local idlerpm = 1500
local maxrpm = 8500
local flywheelweight = 0.02
local slope = (torquemax - torquemin)/(maxrpm-idlerpm)
local inertia = flywheelweight* 3.1416^2
local model = "models/props_c17/TrapPropeller_Engine.mdl"
local modeloffset = Vector(0,1.5,0)
local angleoffset = Angle(-90,0,0)
local modelscale = Vector(0.75,0.75,1)
-------- Please do not modify the what is under here --------


-- Input values --
local throttle = 0
local active = 0
local gearbox = 0

-- output values --
local RPM = 0
local torque = 0 --torque given to each wheel

-- values taken from gearboxes values --
local gearbox = {} -- list of gearboxes
local driving = 0 -- amount of wheels being driven
local gbrpm = 0 -- highest rpm out of every gearbox

if SERVER then
    engine = hologram.create(chip():localToWorld(modeloffset),chip():localToWorldAngles(angleoffset),model,modelscale)
    engine:setParent(chip())
    local enginesound = sound.create(chip(),"Airboat_engine_idle")
    enginesound:setVolume(1,nil)
    enginesound:play()
    chip():setColor(Color(255,255,255,1))
    inputs = {"Throttle" , "Active" , "Gearboxes"}
    inputtypes = {"number","number","array"}
    wire.adjustInputs(inputs, inputtypes, nil)
    
    outputs = {"RPM" , "Torque","Driving"}
    outputstypes = {"number","number","number"}
    wire.adjustOutputs(outputs, outputstypes, nil)
    
    hook.add("Input", "inputupdate", function(Input, value) 
        if Input == "Throttle" then
           throttle = math.clamp(value,0,100)
        end
        if Input == "Active" then
           active = math.clamp(value,0,1)
        end
        if Input == "Gearboxes" then
            for i = 1, #value do
                gearbox[i] = wire.getWirelink(value[i])
            end
        end
        
    end)
        
    timer.create("clock",1/16,0, function()
        gbrpm = 0
        driving = 0
        for i = 1, #gearbox do 
            gbrpm = gbrpm + gearbox[i]["GearboxRPM"]
            driving = driving + gearbox[i]["Driving"]
        end
        gbrpm = gbrpm/#gearbox
        
        torque = RPM * slope * throttle/100 * (RPM < maxrpm and 1 or 0) / math.clamp(driving,1,99999)
        enginesound:setPitch( RPM/maxrpm*125)
        
        
        --gbrpm = math.add(unpack(gearboxrpms))
        wire.triggerOutput(chip(),"Driving",driving)
        if driving == 0 then
            local drag = torquemax * ((RPM-idlerpm)/maxrpm * tonumber(100-throttle)/100)/inertia
            RPM = math.clamp(RPM+torque/inertia - drag,idlerpm,maxrpm)*active
        elseif driving ~= 0 then
            RPM = math.clamp(gbrpm,idlerpm,maxrpm) * active
        end
        wire.triggerOutput(chip(),"RPM",RPM)
        wire.triggerOutput(chip(),"Torque",torque)
    end)
end