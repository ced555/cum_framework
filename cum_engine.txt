--@name cum_framework/CUM engine
--@author
--@server
--@model models/props_c17/SuitCase001a.mdl


--engine has gearbox wirelinks that add up
--engine now check wheels that are being driven, driving output gives amount of wheels being driven
--torque is divided by the amount of wheels that are being driven IN THE ENGINE chip
--rpm = the highest RPM of the wheels of the gearboxes

-- Engine Values --
local torquemin = 40
local torquemax = 110
local idlerpm = 900
local maxrpm = 8000
local flywheelweight = 0.06
local slope = (torquemax - torquemin)/(maxrpm-idlerpm)
local inertia = flywheelweight* 3.1416^2

-- Input values --
local throttle = 0
local active = 0
local gearbox = 0
-- output values --
local RPM = 0
local torque = 0 --torque given to each wheel
-- values taken from gearboxes values --
local gearbox = {} -- list of gearboxes
local driving = 0 -- amount of wheels being driven


local gbrpm = 0 -- highest rpm out of every gearbox


if SERVER then
    engine = hologram.create(chip():localToWorld(Vector(0,1.5,0)),chip():localToWorldAngles(Angle(-90,0,0)),"models/props_c17/TrapPropeller_Engine.mdl",Vector(0.75,0.75,1))
    engine:setParent(chip())
    local enginesound = sound.create(chip(),"Airboat_engine_idle")
    enginesound:setVolume(1,nil)
    enginesound:play()
    chip():setColor(Color(255,255,255,1))
    inputs = {"Throttle" , "Active" , "Gearboxes"}
    inputtypes = {"number","number","array"}
    wire.adjustInputs(inputs, inputtypes, nil)
    
    outputs = {"RPM" , "Torque"}
    outputstypes = {"number","number"}
    wire.adjustOutputs(outputs, outputstypes, nil)
    
    hook.add("Input", "inputupdate", function(Input, value) 
        if Input == "Throttle" then
           throttle = math.clamp(value,0,100)
        end
        if Input == "Active" then
           active = math.clamp(value,0,1)
        end
        if Input == "Gearboxes" then
            for i = 1, #value do
                gearbox[i] = wire.getWirelink(value[i])
            end
        end
        
    end)
        
    timer.create("clock",1/16,0, function()
        gbrpm = 0
        driving = 0
        for i = 1, #gearbox do 
            gbrpm = gbrpm + gearbox[i]["GearboxRPM"]
            driving = driving + gearbox[i]["Driving"]
        end
        gbrpm = gbrpm/#gearbox
        
        torque = RPM * slope * throttle/100 * (RPM < maxrpm and 1 or 0) / math.clamp(driving,1,99999)
        enginesound:setPitch( RPM/maxrpm*125)
        
        
        --gbrpm = math.add(unpack(gearboxrpms))
        --print(gbrpm)
        
        if driving == 0 then
            local drag = torquemax * ((RPM-idlerpm)/maxrpm * tonumber(100-throttle)/100)/inertia
            RPM = math.clamp(RPM+torque/inertia - drag,idlerpm,maxrpm)*active
        elseif driving ~= 0 then
            RPM = math.clamp(idlerpm + gbrpm,idlerpm,maxrpm) * active
        end
        wire.triggerOutput(chip(),"RPM",RPM)
        wire.triggerOutput(chip(),"Torque",torque)
    end)
end